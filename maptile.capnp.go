// Code generated by capnpc-go. DO NOT EDIT.

package main

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	math "math"
)

type Point capnp.Struct

// Point_TypeID is the unique identifier for the type Point.
const Point_TypeID = 0xa521dede354829ed

func NewPoint(s *capnp.Segment) (Point, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0})
	return Point(st), err
}

func NewRootPoint(s *capnp.Segment) (Point, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0})
	return Point(st), err
}

func ReadRootPoint(msg *capnp.Message) (Point, error) {
	root, err := msg.Root()
	return Point(root.Struct()), err
}

func (s Point) String() string {
	str, _ := text.Marshal(0xa521dede354829ed, capnp.Struct(s))
	return str
}

func (s Point) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Point) DecodeFromPtr(p capnp.Ptr) Point {
	return Point(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Point) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Point) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Point) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Point) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Point) X() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(0))
}

func (s Point) SetX(v float64) {
	capnp.Struct(s).SetUint64(0, math.Float64bits(v))
}

func (s Point) Y() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Point) SetY(v float64) {
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s Point) Z() float64 {
	return math.Float64frombits(capnp.Struct(s).Uint64(16))
}

func (s Point) SetZ(v float64) {
	capnp.Struct(s).SetUint64(16, math.Float64bits(v))
}

// Point_List is a list of Point.
type Point_List = capnp.StructList[Point]

// NewPoint creates a new list of Point.
func NewPoint_List(s *capnp.Segment, sz int32) (Point_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 24, PointerCount: 0}, sz)
	return capnp.StructList[Point](l), err
}

// Point_Future is a wrapper for a Point promised by a client call.
type Point_Future struct{ *capnp.Future }

func (f Point_Future) Struct() (Point, error) {
	p, err := f.Future.Ptr()
	return Point(p.Struct()), err
}

type PolyLine capnp.Struct

// PolyLine_TypeID is the unique identifier for the type PolyLine.
const PolyLine_TypeID = 0xc2de746e147ac083

func NewPolyLine(s *capnp.Segment) (PolyLine, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return PolyLine(st), err
}

func NewRootPolyLine(s *capnp.Segment) (PolyLine, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return PolyLine(st), err
}

func ReadRootPolyLine(msg *capnp.Message) (PolyLine, error) {
	root, err := msg.Root()
	return PolyLine(root.Struct()), err
}

func (s PolyLine) String() string {
	str, _ := text.Marshal(0xc2de746e147ac083, capnp.Struct(s))
	return str
}

func (s PolyLine) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (PolyLine) DecodeFromPtr(p capnp.Ptr) PolyLine {
	return PolyLine(capnp.Struct{}.DecodeFromPtr(p))
}

func (s PolyLine) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s PolyLine) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s PolyLine) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s PolyLine) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s PolyLine) Points() (Point_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Point_List(p.List()), err
}

func (s PolyLine) HasPoints() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s PolyLine) SetPoints(v Point_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewPoints sets the points field to a newly
// allocated Point_List, preferring placement in s's segment.
func (s PolyLine) NewPoints(n int32) (Point_List, error) {
	l, err := NewPoint_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Point_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// PolyLine_List is a list of PolyLine.
type PolyLine_List = capnp.StructList[PolyLine]

// NewPolyLine creates a new list of PolyLine.
func NewPolyLine_List(s *capnp.Segment, sz int32) (PolyLine_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[PolyLine](l), err
}

// PolyLine_Future is a wrapper for a PolyLine promised by a client call.
type PolyLine_Future struct{ *capnp.Future }

func (f PolyLine_Future) Struct() (PolyLine, error) {
	p, err := f.Future.Ptr()
	return PolyLine(p.Struct()), err
}

type Lane capnp.Struct

// Lane_TypeID is the unique identifier for the type Lane.
const Lane_TypeID = 0xa73a355efef16d5d

func NewLane(s *capnp.Segment) (Lane, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 7})
	return Lane(st), err
}

func NewRootLane(s *capnp.Segment) (Lane, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 7})
	return Lane(st), err
}

func ReadRootLane(msg *capnp.Message) (Lane, error) {
	root, err := msg.Root()
	return Lane(root.Struct()), err
}

func (s Lane) String() string {
	str, _ := text.Marshal(0xa73a355efef16d5d, capnp.Struct(s))
	return str
}

func (s Lane) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Lane) DecodeFromPtr(p capnp.Ptr) Lane {
	return Lane(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Lane) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Lane) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Lane) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Lane) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Lane) Id() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Lane) HasId() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Lane) IdBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Lane) SetId(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Lane) LeftBoundary() (Lane_LaneBoundary, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Lane_LaneBoundary(p.Struct()), err
}

func (s Lane) HasLeftBoundary() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Lane) SetLeftBoundary(v Lane_LaneBoundary) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewLeftBoundary sets the leftBoundary field to a newly
// allocated Lane_LaneBoundary struct, preferring placement in s's segment.
func (s Lane) NewLeftBoundary() (Lane_LaneBoundary, error) {
	ss, err := NewLane_LaneBoundary(capnp.Struct(s).Segment())
	if err != nil {
		return Lane_LaneBoundary{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Lane) RightBoundary() (Lane_LaneBoundary, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return Lane_LaneBoundary(p.Struct()), err
}

func (s Lane) HasRightBoundary() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Lane) SetRightBoundary(v Lane_LaneBoundary) error {
	return capnp.Struct(s).SetPtr(2, capnp.Struct(v).ToPtr())
}

// NewRightBoundary sets the rightBoundary field to a newly
// allocated Lane_LaneBoundary struct, preferring placement in s's segment.
func (s Lane) NewRightBoundary() (Lane_LaneBoundary, error) {
	ss, err := NewLane_LaneBoundary(capnp.Struct(s).Segment())
	if err != nil {
		return Lane_LaneBoundary{}, err
	}
	err = capnp.Struct(s).SetPtr(2, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Lane) LeftAdjacentId() (string, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.Text(), err
}

func (s Lane) HasLeftAdjacentId() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Lane) LeftAdjacentIdBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.TextBytes(), err
}

func (s Lane) SetLeftAdjacentId(v string) error {
	return capnp.Struct(s).SetText(3, v)
}

func (s Lane) RightAdjacentId() (string, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return p.Text(), err
}

func (s Lane) HasRightAdjacentId() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Lane) RightAdjacentIdBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return p.TextBytes(), err
}

func (s Lane) SetRightAdjacentId(v string) error {
	return capnp.Struct(s).SetText(4, v)
}

func (s Lane) InboundIds() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return capnp.TextList(p.List()), err
}

func (s Lane) HasInboundIds() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s Lane) SetInboundIds(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(5, v.ToPtr())
}

// NewInboundIds sets the inboundIds field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Lane) NewInboundIds(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(5, l.ToPtr())
	return l, err
}
func (s Lane) OutboundIds() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(6)
	return capnp.TextList(p.List()), err
}

func (s Lane) HasOutboundIds() bool {
	return capnp.Struct(s).HasPtr(6)
}

func (s Lane) SetOutboundIds(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(6, v.ToPtr())
}

// NewOutboundIds sets the outboundIds field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s Lane) NewOutboundIds(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(6, l.ToPtr())
	return l, err
}

// Lane_List is a list of Lane.
type Lane_List = capnp.StructList[Lane]

// NewLane creates a new list of Lane.
func NewLane_List(s *capnp.Segment, sz int32) (Lane_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 7}, sz)
	return capnp.StructList[Lane](l), err
}

// Lane_Future is a wrapper for a Lane promised by a client call.
type Lane_Future struct{ *capnp.Future }

func (f Lane_Future) Struct() (Lane, error) {
	p, err := f.Future.Ptr()
	return Lane(p.Struct()), err
}
func (p Lane_Future) LeftBoundary() Lane_LaneBoundary_Future {
	return Lane_LaneBoundary_Future{Future: p.Future.Field(1, nil)}
}
func (p Lane_Future) RightBoundary() Lane_LaneBoundary_Future {
	return Lane_LaneBoundary_Future{Future: p.Future.Field(2, nil)}
}

type Lane_LaneBoundary capnp.Struct

// Lane_LaneBoundary_TypeID is the unique identifier for the type Lane_LaneBoundary.
const Lane_LaneBoundary_TypeID = 0xdb6652f89b03abbf

func NewLane_LaneBoundary(s *capnp.Segment) (Lane_LaneBoundary, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Lane_LaneBoundary(st), err
}

func NewRootLane_LaneBoundary(s *capnp.Segment) (Lane_LaneBoundary, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1})
	return Lane_LaneBoundary(st), err
}

func ReadRootLane_LaneBoundary(msg *capnp.Message) (Lane_LaneBoundary, error) {
	root, err := msg.Root()
	return Lane_LaneBoundary(root.Struct()), err
}

func (s Lane_LaneBoundary) String() string {
	str, _ := text.Marshal(0xdb6652f89b03abbf, capnp.Struct(s))
	return str
}

func (s Lane_LaneBoundary) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Lane_LaneBoundary) DecodeFromPtr(p capnp.Ptr) Lane_LaneBoundary {
	return Lane_LaneBoundary(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Lane_LaneBoundary) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Lane_LaneBoundary) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Lane_LaneBoundary) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Lane_LaneBoundary) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Lane_LaneBoundary) PolyLine() (PolyLine, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return PolyLine(p.Struct()), err
}

func (s Lane_LaneBoundary) HasPolyLine() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Lane_LaneBoundary) SetPolyLine(v PolyLine) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewPolyLine sets the polyLine field to a newly
// allocated PolyLine struct, preferring placement in s's segment.
func (s Lane_LaneBoundary) NewPolyLine() (PolyLine, error) {
	ss, err := NewPolyLine(capnp.Struct(s).Segment())
	if err != nil {
		return PolyLine{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Lane_LaneBoundary) StartHeading() float32 {
	return math.Float32frombits(capnp.Struct(s).Uint32(0))
}

func (s Lane_LaneBoundary) SetStartHeading(v float32) {
	capnp.Struct(s).SetUint32(0, math.Float32bits(v))
}

// Lane_LaneBoundary_List is a list of Lane_LaneBoundary.
type Lane_LaneBoundary_List = capnp.StructList[Lane_LaneBoundary]

// NewLane_LaneBoundary creates a new list of Lane_LaneBoundary.
func NewLane_LaneBoundary_List(s *capnp.Segment, sz int32) (Lane_LaneBoundary_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz)
	return capnp.StructList[Lane_LaneBoundary](l), err
}

// Lane_LaneBoundary_Future is a wrapper for a Lane_LaneBoundary promised by a client call.
type Lane_LaneBoundary_Future struct{ *capnp.Future }

func (f Lane_LaneBoundary_Future) Struct() (Lane_LaneBoundary, error) {
	p, err := f.Future.Ptr()
	return Lane_LaneBoundary(p.Struct()), err
}
func (p Lane_LaneBoundary_Future) PolyLine() PolyLine_Future {
	return PolyLine_Future{Future: p.Future.Field(0, nil)}
}

type TileSummary capnp.Struct

// TileSummary_TypeID is the unique identifier for the type TileSummary.
const TileSummary_TypeID = 0x89bfe583cb912e78

func NewTileSummary(s *capnp.Segment) (TileSummary, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return TileSummary(st), err
}

func NewRootTileSummary(s *capnp.Segment) (TileSummary, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return TileSummary(st), err
}

func ReadRootTileSummary(msg *capnp.Message) (TileSummary, error) {
	root, err := msg.Root()
	return TileSummary(root.Struct()), err
}

func (s TileSummary) String() string {
	str, _ := text.Marshal(0x89bfe583cb912e78, capnp.Struct(s))
	return str
}

func (s TileSummary) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (TileSummary) DecodeFromPtr(p capnp.Ptr) TileSummary {
	return TileSummary(capnp.Struct{}.DecodeFromPtr(p))
}

func (s TileSummary) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s TileSummary) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s TileSummary) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s TileSummary) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s TileSummary) Version() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s TileSummary) HasVersion() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s TileSummary) VersionBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s TileSummary) SetVersion(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s TileSummary) UpdatedAt() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s TileSummary) SetUpdatedAt(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

func (s TileSummary) Level() uint8 {
	return capnp.Struct(s).Uint8(8)
}

func (s TileSummary) SetLevel(v uint8) {
	capnp.Struct(s).SetUint8(8, v)
}

func (s TileSummary) X() uint16 {
	return capnp.Struct(s).Uint16(10)
}

func (s TileSummary) SetX(v uint16) {
	capnp.Struct(s).SetUint16(10, v)
}

func (s TileSummary) Y() uint16 {
	return capnp.Struct(s).Uint16(12)
}

func (s TileSummary) SetY(v uint16) {
	capnp.Struct(s).SetUint16(12, v)
}

// TileSummary_List is a list of TileSummary.
type TileSummary_List = capnp.StructList[TileSummary]

// NewTileSummary creates a new list of TileSummary.
func NewTileSummary_List(s *capnp.Segment, sz int32) (TileSummary_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1}, sz)
	return capnp.StructList[TileSummary](l), err
}

// TileSummary_Future is a wrapper for a TileSummary promised by a client call.
type TileSummary_Future struct{ *capnp.Future }

func (f TileSummary_Future) Struct() (TileSummary, error) {
	p, err := f.Future.Ptr()
	return TileSummary(p.Struct()), err
}

type MapTile capnp.Struct

// MapTile_TypeID is the unique identifier for the type MapTile.
const MapTile_TypeID = 0xa22d518a2b2f584b

func NewMapTile(s *capnp.Segment) (MapTile, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return MapTile(st), err
}

func NewRootMapTile(s *capnp.Segment) (MapTile, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return MapTile(st), err
}

func ReadRootMapTile(msg *capnp.Message) (MapTile, error) {
	root, err := msg.Root()
	return MapTile(root.Struct()), err
}

func (s MapTile) String() string {
	str, _ := text.Marshal(0xa22d518a2b2f584b, capnp.Struct(s))
	return str
}

func (s MapTile) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (MapTile) DecodeFromPtr(p capnp.Ptr) MapTile {
	return MapTile(capnp.Struct{}.DecodeFromPtr(p))
}

func (s MapTile) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s MapTile) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s MapTile) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s MapTile) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s MapTile) Summary() (TileSummary, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return TileSummary(p.Struct()), err
}

func (s MapTile) HasSummary() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s MapTile) SetSummary(v TileSummary) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewSummary sets the summary field to a newly
// allocated TileSummary struct, preferring placement in s's segment.
func (s MapTile) NewSummary() (TileSummary, error) {
	ss, err := NewTileSummary(capnp.Struct(s).Segment())
	if err != nil {
		return TileSummary{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s MapTile) Lanes() (Lane_List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Lane_List(p.List()), err
}

func (s MapTile) HasLanes() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s MapTile) SetLanes(v Lane_List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewLanes sets the lanes field to a newly
// allocated Lane_List, preferring placement in s's segment.
func (s MapTile) NewLanes(n int32) (Lane_List, error) {
	l, err := NewLane_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Lane_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}

// MapTile_List is a list of MapTile.
type MapTile_List = capnp.StructList[MapTile]

// NewMapTile creates a new list of MapTile.
func NewMapTile_List(s *capnp.Segment, sz int32) (MapTile_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[MapTile](l), err
}

// MapTile_Future is a wrapper for a MapTile promised by a client call.
type MapTile_Future struct{ *capnp.Future }

func (f MapTile_Future) Struct() (MapTile, error) {
	p, err := f.Future.Ptr()
	return MapTile(p.Struct()), err
}
func (p MapTile_Future) Summary() TileSummary_Future {
	return TileSummary_Future{Future: p.Future.Field(0, nil)}
}

const schema_a086df597ef5d7a0 = "x\xdatTQh\x1cU\x14=\xe7\xbd\xd9\xdd\xb4\xdd" +
	"\xa6;\xee\x82 B\x10*\x18\xcc\x8e[c\x7f\x82\x90" +
	"\xa6TH4\x85\xdc\xa6\x1fVP\x98v\xa6q\xc2\xe6" +
	"\xed\xb2\x99m\xb3\x01\xad\xda\"V*ZPP\x8bP" +
	"\x0b\xc5\x0f?\x14\xa1`Ei+~\x18\xf4\xc3\x8aE" +
	"E\x89_~\x89`A\xc1/G\xdelwv\xd9*" +
	"\xfbs\xb9\xf7\xec\xbd\xe7\xdcs\xe7\xd5\xce\x15\xf78\xbb" +
	"\xb6/\x1d\x82Z,9\xb9|\xb2\xe6\x9d\xfd\xea\xe4\xaf" +
	"WNCF\xa9\x92\xf3\xdf\xff\xf5\xec\xa1_^<\x8f" +
	"\x1c\x0b@\xf9\xad\x89o\xcb\x17'\x0a\xc0\xe4\xbb\x13c" +
	"\x04\x93\xc7\x1e\x7f\xe0\xfe\x97\xa5z\x01\xee(\x07\xc0\xca" +
	"\x82/U?*\x7fV\xb5\xd1\xe5\xeaq0\xf9}|" +
	"v\xf7\xe6\xe6=\x17mg\xdd\x07;\x16q\xafw\xa1" +
	"\\\xf5l4\xee}\x00&O\xae\xdc\xfc\xe7\xa9\xddS" +
	"\xef\x0d\xf5-X\xc45\xef\xed\xf2\x86w'0y\xc3" +
	"{\xd5\x928yu\xbdb\xe2\xcd\xcf\x87\xc0)\xe37" +
	"j\x9f\x94\xdf\xa9\xa5\xdck\xd3`r\xe5}}\xee\xef" +
	"\x03G\x7f\x82\x9490&\x05On\xd4\x14\xcb7R" +
	"\xf4\xf5\xdaq$\xff\xf1\xfb-Y\xf1\x9bqT\x0f=" +
	"u\xc4o\x9a\xe6\xd4\xc1\xa8\x1e.\xb6WV\xfc\x16;" +
	"\x0b\xa4T\xb4\x038\x04\xdcg\xf6\x02\xb2\xa6)\xa7\x14" +
	"\xc9\x0am\xee\xf9\x03\x80<\xa7)g\x14]5R\xa1" +
	"\x02\xdc\xd3\x0f\x02rJS^Stu\xaeB\x0d\xb8" +
	"\xaf\xdc\x01\xc8K\x9a\xf2\xba\xa2\xeb\xe4+t\x00\xf7\xac" +
	"M\x9e\xd1\x947\x15O\x1c\x0b[\xabQ\xc3\xb0\x08\xc5" +
	"\"\x98\xb4\x9b\x81\x1f\x87\xc1\x0c\x18s\x0b\x14\xb7\x80c" +
	"\xf5\xf0XXg\x1e\x8ay\x90k,@\xb1\x00\xb2\xd3" +
	"\x8b29\xec\xca\xd9\xef\x8f5\xad$+e$\x932" +
	"n\xa5\xec\xd4\x94\x9a\xa2\xdb\xd3R\xb5\xb4\xef\xd3\x94}" +
	"\x8a'V\xd3\x15tX\xea\x1f\x10\xc8\x92\xa5\xe0\x9bp" +
	"\x95\xa3\xe0\x82&K\xfd\x95\x8369<\x7f\xa1Q\x88" +
	"Ll\xa7\x17\xb3\xe9\x8fX\xd5{4e~`\xfa\x9c" +
	"M\xee\xd3\x94\x05\xbbI\xd5\xdd\xe4~\x9b\x9c\xd5\x94\x83" +
	"\xca\xaa\xdd\x06\xc5m\xa9\xda^\xb4\xde\x8b\x86\xe7\xce\xfb" +
	"\xda\x84\xe2p\xe0B\\.'\xf3\xbe\x09\xf76\xda\x06" +
	";\x02\xbf\xd5\x91\xbb3N\x97\xee\x02\xe4CM\xf9t" +
	"\x80\xd3\xe5e@>\xd6\x94/\x068]k\x01rU" +
	"S\xbe\xb6\xee\xea\xae\xbb\x1b\xeb\x80|\xa9)\xdfYw" +
	"\x9d\xae\xbb\xd7_\x00\xe4\x1bM\xf9Y\xd1\xcd\xe5*\xcc" +
	"\x01\xee\x8fO\x00\xf2\x83\xa6\xfc\xa9\xe8\xe6\xf3\x15\xe6\x01" +
	"\xf7\xe6a@\xfe\xd0\\,RQGAv\x03\xf5\xf0" +
	"h\xdc\xe7\xcbR_M\xd7\x8d\xa4\x15-=m\x11\x18" +
	"3\xff\x83\xb0-f\x82e\x1f\xd3GB\x13\xcf\xf5{" +
	"\xa7\x7f\x9d\x09\x96\xe9w\x0b\xc8*\x919\xdch\x9b`" +
	"\x0e:\xc8\x9c\xb65\xebo\xa3\x1d\xa7E\x14\xe6n/" +
	"\xdef\xfet\xbd3\x1f\x99\xf4\xfa\x9cl\xd7\xdb\xa7\x00" +
	"\x19\xd1\x94\x9d\x8a\xd3\xcdFd\xe2\x81{\xca^\x95\xa1" +
	"{\xd2=_M\xe8\xf5\\\xb4\x8a1t\xd9\x8f\xde:" +
	"\xe2\x87\xfa\x1f\xe9.kcMS\x1eVL\x9a\x8d." +
	"%\x00,\xf5\x9f\x9a[\xcbZ\x8d\xfdV<\x1b\xfa\xd8" +
	"\x11Df\x89[\xa1\xb8\x15\xfc7\x00\x00\xff\xff\x99\x89" +
	"P\xbc"

func RegisterMaptileSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_a086df597ef5d7a0,
		Nodes: []uint64{
			0x89bfe583cb912e78,
			0xa22d518a2b2f584b,
			0xa521dede354829ed,
			0xa73a355efef16d5d,
			0xc2de746e147ac083,
			0xdb6652f89b03abbf,
		},
		Compressed: true,
	})
}
